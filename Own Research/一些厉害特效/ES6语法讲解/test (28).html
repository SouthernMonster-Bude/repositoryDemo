<html><head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="stylesheet" href="css/normalize.css">
  <link rel="stylesheet" href="css/app.css">
  <title>ECMAScript 6 简介 - ECMAScript 6入门</title>
  </head>
<body style="">
<!-- essential -->
<div id="sidebar"><h1 id="-ecmascript-6-"><a href="">ECMAScript 6 入门</a></h1>
  <p>作者：<a href="http://www.ruanyifeng.com">阮一峰</a></p>
  <p>授权：<a rel="license" href="http://creativecommons.org/licenses/by-nc/4.0/">署名-非商用许可证</a></p>
  <ol start="0">
    <li><a href="#README">前言</a></li>
    <li><a href="test (0).html">ECMAScript 6简介</a></li>
    <li><a href="test (1).html">let 和 const 命令</a></li>
    <li><a href="test (2).html">变量的解构赋值</a></li>
    <li><a href="test (3).html">字符串的扩展</a></li>
    <li><a href="test (4).html">字符串的新增方法</a></li>
    <li><a href="test (5).html">正则的扩展</a></li>
    <li><a href="test (6).html">数值的扩展</a></li>
    <li><a href="test (7).html">函数的扩展</a></li>
    <li><a href="test (8).html">数组的扩展</a></li>
    <li><a href="test (9).html">对象的扩展</a></li>
    <li><a href="test (10).html">对象的新增方法</a></li>
    <li><a href="test (11).html">Symbol</a></li>
    <li><a href="test (12).html">Set 和 Map 数据结构</a></li>
    <li><a href="test (13).html">Proxy</a></li>
    <li><a href="test (14).html">Reflect</a></li>
    <li><a href="test (15).html">Promise 对象</a></li>
    <li><a href="test (16).html">Iterator 和 for...of 循环</a></li>
    <li><a href="test (17).html">Generator 函数的语法</a></li>
    <li><a href="test (18).html">Generator 函数的异步应用</a></li>
    <li><a href="test (19).html">async 函数</a></li>
    <li><a href="test (20).html">Class 的基本语法</a></li>
    <li><a href="test (21).html">Class 的继承</a></li>
    <li><a href="test (22).html">Module 的语法</a></li>
    <li><a href="test (23).html">Module 的加载实现</a></li>
    <li><a href="test (24).html">编程风格</a></li>
    <li><a href="test (25).html">读懂规格</a></li>
    <li><a href="test (26).html">异步遍历器</a></li>
    <li><a href="test (27).html">ArrayBuffer</a></li>
    <li><a href="test (28).html">最新提案</a></li>
    <li><a href="test (29).html">Decorator</a></li>
    <li><a href="test (30).html">参考链接</a></li>
  </ol>
<h2 id="-">其他</h2>
<ul>
<li><a href="http://github.com/ruanyf/es6tutorial/">源码</a></li>
<li><a href="https://github.com/ruanyf/es6tutorial/commits/gh-pages">修订历史</a></li>
<li><a href="https://github.com/ruanyf/es6tutorial/issues">反馈意见</a></li>
</ul>
</div>
  <div id="content"><h1 id="-">最新提案</h1><ol class="content-toc" id="content-toc"><li data-src="do-表达式" class="link"><a href="#docs/proposals#do 表达式">do 表达式</a></li><li data-src="throw-表达式" class="link"><a href="#docs/proposals#throw 表达式">throw 表达式</a></li><li data-src="链判断运算符" class="link"><a href="#docs/proposals#链判断运算符">链判断运算符</a></li><li data-src="Null-判断运算符" class="link"><a href="#docs/proposals#Null 判断运算符">Null 判断运算符</a></li><li data-src="函数的部分执行" class="link"><a href="#docs/proposals#函数的部分执行">函数的部分执行</a></li><li data-src="管道运算符" class="link"><a href="#docs/proposals#管道运算符">管道运算符</a></li><li data-src="数值分隔符" class="link"><a href="#docs/proposals#数值分隔符">数值分隔符</a></li><li data-src="BigInt-数据类型" class="link"><a href="#docs/proposals#BigInt 数据类型">BigInt 数据类型</a></li><li data-src="Math-signbit" class="link"><a href="#docs/proposals#Math.signbit()">Math.signbit()</a></li><li data-src="双冒号运算符" class="link"><a href="#docs/proposals#双冒号运算符">双冒号运算符</a></li><li data-src="Realm-API" class="link"><a href="#docs/proposals#Realm API">Realm API</a></li><li data-src="-!命令" class="link"><a href="#docs/proposals##!命令">#!命令</a></li><li data-src="import-meta" class="link"><a href="#docs/proposals#import.meta">import.meta</a></li></ol>
<p>本章介绍一些尚未进入标准、但很有希望的最新提案。</p>
<h2 id="do-表达式" class="do-表达式">do 表达式</h2>
<p>本质上，块级作用域是一个语句，将多个操作封装在一起，没有返回值。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token punctuation">{</span>
  <span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  t <span class="token operator">=</span> t <span class="token operator">*</span> t <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面代码中，块级作用域将两个语句封装在一起。但是，在块级作用域以外，没有办法得到<code>t</code>的值，因为块级作用域不返回值，除非<code>t</code>是全局变量。</p>
<p>现在有一个<a href="https://github.com/tc39/proposal-do-expressions">提案</a>，使得块级作用域可以变为表达式，也就是说可以返回值，办法就是在块级作用域之前加上<code>do</code>，使它变为<code>do</code>表达式，然后就会返回内部最后执行的表达式的值。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token keyword">do</span> <span class="token punctuation">{</span>
  <span class="token keyword">let</span> t <span class="token operator">=</span> <span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  t <span class="token operator">*</span> t <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>上面代码中，变量<code>x</code>会得到整个块级作用域的返回值（<code>t * t + 1</code>）。</p>
<p><code>do</code>表达式的逻辑非常简单：封装的是什么，就会返回什么。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token comment" spellcheck="true">// 等同于 &lt;表达式&gt;
</span><span class="token keyword">do</span> <span class="token punctuation">{</span> <span class="token operator">&lt;</span>表达式<span class="token operator">&gt;</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">
// 等同于 &lt;语句&gt;
</span><span class="token keyword">do</span> <span class="token punctuation">{</span> <span class="token operator">&lt;</span>语句<span class="token operator">&gt;</span> <span class="token punctuation">}</span>
</code></pre>
<p><code>do</code>表达式的好处是可以封装多个语句，让程序更加模块化，就像乐高积木那样一块块拼装起来。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token keyword">do</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">foo<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
  <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token function">bar<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token function">g<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
  <span class="token keyword">else</span> <span class="token punctuation">{</span> <span class="token function">h<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre>
<p>上面代码的本质，就是根据函数<code>foo</code>的执行结果，调用不同的函数，将返回结果赋给变量<code>x</code>。使用<code>do</code>表达式，就将这个操作的意图表达得非常简洁清晰。而且，<code>do</code>块级作用域提供了单独的作用域，内部操作可以与全局作用域隔绝。</p>
<p>值得一提的是，<code>do</code>表达式在 JSX 语法中非常好用。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">return</span> <span class="token punctuation">(</span>
  <span class="token operator">&lt;</span>nav<span class="token operator">&gt;</span>
    <span class="token operator">&lt;</span>Home <span class="token operator">/</span><span class="token operator">&gt;</span>
    <span class="token punctuation">{</span>
      <span class="token keyword">do</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>loggedIn<span class="token punctuation">)</span> <span class="token punctuation">{</span>
          <span class="token operator">&lt;</span>LogoutButton <span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
          <span class="token operator">&lt;</span>LoginButton <span class="token operator">/</span><span class="token operator">&gt;</span>
        <span class="token punctuation">}</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
  <span class="token operator">&lt;</span><span class="token operator">/</span>nav<span class="token operator">&gt;</span>
<span class="token punctuation">)</span>
</code></pre>
<p>上面代码中，如果不用<code>do</code>表达式，就只能用三元判断运算符（<code>?:</code>）。那样的话，一旦判断逻辑复杂，代码就会变得很不易读。</p>
<h2 id="throw-表达式" class="throw-表达式">throw 表达式</h2>
<p>JavaScript 语法规定<code>throw</code>是一个命令，用来抛出错误，不能用于表达式之中。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token comment" spellcheck="true">// 报错
</span>console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span><span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>上面代码中，<code>console.log</code>的参数必须是一个表达式，如果是一个<code>throw</code>语句就会报错。</p>
<p>现在有一个<a href="https://github.com/tc39/proposal-throw-expressions">提案</a>，允许<code>throw</code>用于表达式。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token comment" spellcheck="true">// 参数的默认值
</span><span class="token keyword">function</span> <span class="token function">save<span class="token punctuation">(</span></span>filename <span class="token operator">=</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">"Argument required"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">
// 箭头函数的返回值
</span><span class="token function">lint<span class="token punctuation">(</span></span>ast<span class="token punctuation">,</span> <span class="token punctuation">{</span>
  <span class="token keyword">with</span><span class="token punctuation">:</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"avoid using 'with' statements."</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">
// 条件表达式
</span><span class="token keyword">function</span> <span class="token function">getEncoder<span class="token punctuation">(</span></span>encoding<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  const encoder <span class="token operator">=</span> encoding <span class="token operator">===</span> <span class="token string">"utf8"</span> <span class="token operator">?</span>
    <span class="token keyword">new</span> <span class="token class-name">UTF8Encoder</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>
    encoding <span class="token operator">===</span> <span class="token string">"utf16le"</span> <span class="token operator">?</span>
      <span class="token keyword">new</span> <span class="token class-name">UTF16Encoder</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>
      encoding <span class="token operator">===</span> <span class="token string">"utf16be"</span> <span class="token operator">?</span>
        <span class="token keyword">new</span> <span class="token class-name">UTF16Encoder</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span> <span class="token punctuation">:</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Unsupported encoding"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment" spellcheck="true">
// 逻辑表达式
</span>class <span class="token class-name">Product</span> <span class="token punctuation">{</span>
  <span class="token keyword">get</span> <span class="token function">id<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_id<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">set</span> <span class="token function">id<span class="token punctuation">(</span></span>value<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>_id <span class="token operator">=</span> value <span class="token operator">||</span> <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">"Invalid value"</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面代码中，<code>throw</code>都出现在表达式里面。</p>
<p>语法上，<code>throw</code>表达式里面的<code>throw</code>不再是一个命令，而是一个运算符。为了避免与<code>throw</code>命令混淆，规定<code>throw</code>出现在行首，一律解释为<code>throw</code>语句，而不是<code>throw</code>表达式。</p>
<h2 id="链判断运算符" class="链判断运算符">链判断运算符</h2>
<p>编程实务中，如果读取对象内部的某个属性，往往需要判断一下该对象是否存在。比如，要读取<code>message.body.user.firstName</code>，安全的写法是写成下面这样。</p>
<pre class=" language-javascript"><code class=" language-javascript">const firstName <span class="token operator">=</span> <span class="token punctuation">(</span>message
  <span class="token operator">&amp;&amp;</span> message<span class="token punctuation">.</span>body
  <span class="token operator">&amp;&amp;</span> message<span class="token punctuation">.</span>body<span class="token punctuation">.</span>user
  <span class="token operator">&amp;&amp;</span> message<span class="token punctuation">.</span>body<span class="token punctuation">.</span>user<span class="token punctuation">.</span>firstName<span class="token punctuation">)</span> <span class="token operator">||</span> <span class="token string">'default'</span><span class="token punctuation">;</span>
</code></pre>
<p>或者使用三元运算符<code>?:</code>，判断一个对象是否存在。</p>
<pre class=" language-javascript"><code class=" language-javascript">const fooInput <span class="token operator">=</span> myForm<span class="token punctuation">.</span><span class="token function">querySelector<span class="token punctuation">(</span></span><span class="token string">'input[name=foo]'</span><span class="token punctuation">)</span>
const fooValue <span class="token operator">=</span> fooInput <span class="token operator">?</span> fooInput<span class="token punctuation">.</span>value <span class="token punctuation">:</span> undefined
</code></pre>
<p>这样的层层判断非常麻烦，因此现在有一个<a href="https://github.com/tc39/proposal-optional-chaining">提案</a>，引入了“链判断运算符”（optional chaining operator）<code>?.</code>，简化上面的写法。</p>
<pre class=" language-javascript"><code class=" language-javascript">const firstName <span class="token operator">=</span> message<span class="token operator">?</span><span class="token punctuation">.</span>body<span class="token operator">?</span><span class="token punctuation">.</span>user<span class="token operator">?</span><span class="token punctuation">.</span>firstName <span class="token operator">||</span> <span class="token string">'default'</span><span class="token punctuation">;</span>
const fooValue <span class="token operator">=</span> myForm<span class="token punctuation">.</span><span class="token function">querySelector<span class="token punctuation">(</span></span><span class="token string">'input[name=foo]'</span><span class="token punctuation">)</span><span class="token operator">?</span><span class="token punctuation">.</span>value
</code></pre>
<p>上面代码使用了<code>?.</code>运算符，直接在链式调用的时候判断，左侧的对象是否为<code>null</code>或<code>undefined</code>。如果是的，就不再往下运算，而是返回<code>undefined</code>。</p>
<p>链判断运算符有三种用法。</p>
<ul>
<li><code>obj?.prop</code> // 对象属性</li>
<li><code>obj?.[expr]</code> // 同上</li>
<li><code>func?.(...args)</code> // 函数或对象方法的调用</li>
</ul>
<p>下面是判断对象方法是否存在，如果存在就立即执行的例子。</p>
<pre class=" language-javascript"><code class=" language-javascript">iterator<span class="token punctuation">.</span><span class="token keyword">return</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre>
<p>上面代码中，<code>iterator.return</code>如果有定义，就会调用该方法，否则直接返回<code>undefined</code>。</p>
<p>对于那些可能没有实现的方法，这个运算符尤其有用。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span>myForm<span class="token punctuation">.</span>checkValidity<span class="token operator">?</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">===</span> <span class="token boolean">false</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
 <span class="token comment" spellcheck="true"> // 表单校验失败
</span>  <span class="token keyword">return</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面代码中，老式浏览器的表单可能没有<code>checkValidity</code>这个方法，这时<code>?.</code>运算符就会返回<code>undefined</code>，判断语句就变成了<code>undefined === false</code>，所以就会跳过下面的代码。</p>
<p>下面是这个运算符常见的使用形式，以及不使用该运算符时的等价形式。</p>
<pre class=" language-javascript"><code class=" language-javascript">a<span class="token operator">?</span><span class="token punctuation">.</span>b<span class="token comment" spellcheck="true">
// 等同于
</span>a <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> undefined <span class="token punctuation">:</span> a<span class="token punctuation">.</span>b

a<span class="token operator">?</span><span class="token punctuation">.</span><span class="token punctuation">[</span>x<span class="token punctuation">]</span><span class="token comment" spellcheck="true">
// 等同于
</span>a <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> undefined <span class="token punctuation">:</span> a<span class="token punctuation">[</span>x<span class="token punctuation">]</span>

a<span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">b<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">
// 等同于
</span>a <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> undefined <span class="token punctuation">:</span> a<span class="token punctuation">.</span><span class="token function">b<span class="token punctuation">(</span></span><span class="token punctuation">)</span>

a<span class="token operator">?</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">
// 等同于
</span>a <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> undefined <span class="token punctuation">:</span> <span class="token function">a<span class="token punctuation">(</span></span><span class="token punctuation">)</span>
</code></pre>
<p>上面代码中，特别注意后两种形式，如果<code>a?.b()</code>里面的<code>a.b</code>不是函数，不可调用，那么<code>a?.b()</code>是会报错的。<code>a?.()</code>也是如此，如果<code>a</code>不是<code>null</code>或<code>undefined</code>，但也不是函数，那么<code>a?.()</code>会报错。</p>
<p>使用这个运算符，有几个注意点。</p>
<p>（1）短路机制</p>
<pre class=" language-javascript"><code class=" language-javascript">a<span class="token operator">?</span><span class="token punctuation">.</span><span class="token punctuation">[</span><span class="token operator">++</span>x<span class="token punctuation">]</span><span class="token comment" spellcheck="true">
// 等同于
</span>a <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> undefined <span class="token punctuation">:</span> a<span class="token punctuation">[</span><span class="token operator">++</span>x<span class="token punctuation">]</span>
</code></pre>
<p>上面代码中，如果<code>a</code>是<code>undefined</code>或<code>null</code>，那么<code>x</code>不会进行递增运算。也就是说，链判断运算符一旦为真，右侧的表达式就不再求值。</p>
<p>（2）delete 运算符</p>
<pre class=" language-javascript"><code class=" language-javascript">delete a<span class="token operator">?</span><span class="token punctuation">.</span>b<span class="token comment" spellcheck="true">
// 等同于
</span>a <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> undefined <span class="token punctuation">:</span> delete a<span class="token punctuation">.</span>b
</code></pre>
<p>上面代码中，如果<code>a</code>是<code>undefined</code>或<code>null</code>，会直接返回<code>undefined</code>，而不会进行<code>delete</code>运算。</p>
<p>（3）括号不改变运算顺序</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token punctuation">(</span>a<span class="token operator">?</span><span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span>c<span class="token comment" spellcheck="true">
// 等价于
</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token keyword">null</span> <span class="token operator">?</span> undefined <span class="token punctuation">:</span> a<span class="token punctuation">.</span>b<span class="token punctuation">)</span><span class="token punctuation">.</span>c
</code></pre>
<p>上面代码中，<code>?.</code>对圆括号没有影响，不管<code>a</code>对象是否存在，圆括号后面的<code>.c</code>总是会执行。</p>
<p>一般来说，使用<code>?.</code>运算符的场合，不应该使用圆括号。</p>
<p>（4）报错场合</p>
<p>以下写法是禁止的，会报错。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token comment" spellcheck="true">// 构造函数
</span><span class="token keyword">new</span> <span class="token class-name">a</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">new</span> <span class="token class-name">a</span><span class="token operator">?</span><span class="token punctuation">.</span><span class="token function">b<span class="token punctuation">(</span></span><span class="token punctuation">)</span>
<span class="token comment" spellcheck="true">
// 链判断运算符的右侧有模板字符串
</span>a<span class="token operator">?</span><span class="token punctuation">.</span>`<span class="token punctuation">{</span>b<span class="token punctuation">}</span>`
a<span class="token operator">?</span><span class="token punctuation">.</span>b`<span class="token punctuation">{</span>c<span class="token punctuation">}</span>`
<span class="token comment" spellcheck="true">
// 链判断运算符的左侧是 super
</span>super<span class="token operator">?</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
super<span class="token operator">?</span><span class="token punctuation">.</span>foo
<span class="token comment" spellcheck="true">
// 链运算符用于赋值运算符左侧
</span>a<span class="token operator">?</span><span class="token punctuation">.</span>b <span class="token operator">=</span> c
</code></pre>
<p>（5）右侧不得为十进制数值</p>
<p>为了保证兼容以前的代码，允许<code>foo?.3:0</code>被解析成<code>foo ? .3 : 0</code>，因此规定如果<code>?.</code>后面紧跟一个十进制数字，那么<code>?.</code>不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数。</p>
<h2 id="Null-判断运算符" class="Null-判断运算符">Null 判断运算符</h2>
<p>读取对象属性的时候，如果某个属性的值是<code>null</code>或<code>undefined</code>，有时候需要为它们指定默认值。常见做法是通过<code>||</code>运算符指定默认值。</p>
<pre class=" language-javascript"><code class=" language-javascript">const headerText <span class="token operator">=</span> response<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>headerText <span class="token operator">||</span> <span class="token string">'Hello, world!'</span><span class="token punctuation">;</span>
const animationDuration <span class="token operator">=</span> response<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>animationDuration <span class="token operator">||</span> <span class="token number">300</span><span class="token punctuation">;</span>
const showSplashScreen <span class="token operator">=</span> response<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>showSplashScreen <span class="token operator">||</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre>
<p>上面的三行代码都通过<code>||</code>运算符指定默认值，但是这样写是错的。开发者的原意是，只要属性的值为<code>null</code>或<code>undefined</code>，默认值就会生效，但是属性的值如果为空字符串或<code>false</code>或<code>0</code>，默认值也会生效。</p>
<p>为了避免这种情况，现在有一个<a href="https://github.com/tc39/proposal-nullish-coalescing">提案</a>，引入了一个新的 Null 判断运算符<code>??</code>。它的行为类似<code>||</code>，但是只有运算符左侧的值为<code>null</code>或<code>undefined</code>时，才会返回右侧的值。</p>
<pre class=" language-javascript"><code class=" language-javascript">const headerText <span class="token operator">=</span> response<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>headerText <span class="token operator">?</span><span class="token operator">?</span> <span class="token string">'Hello, world!'</span><span class="token punctuation">;</span>
const animationDuration <span class="token operator">=</span> response<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>animationDuration <span class="token operator">?</span><span class="token operator">?</span> <span class="token number">300</span><span class="token punctuation">;</span>
const showSplashScreen <span class="token operator">=</span> response<span class="token punctuation">.</span>settings<span class="token punctuation">.</span>showSplashScreen <span class="token operator">?</span><span class="token operator">?</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
</code></pre>
<p>上面代码中，默认值只有在属性值为<code>null</code>或<code>undefined</code>时，才会生效。</p>
<p>这个运算符可以跟链判断运算符<code>?.</code>配合使用。</p>
<pre class=" language-javascript"><code class=" language-javascript">const animationDuration <span class="token operator">=</span> response<span class="token punctuation">.</span>settings<span class="token operator">?</span><span class="token punctuation">.</span>animationDuration <span class="token operator">?</span><span class="token operator">?</span> <span class="token number">300</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="函数的部分执行" class="函数的部分执行">函数的部分执行</h2>
<h3 id="语法" class="语法">语法</h3>
<p>多参数的函数有时需要绑定其中的一个或多个参数，然后返回一个新函数。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> <span class="token function">add<span class="token punctuation">(</span></span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">add7<span class="token punctuation">(</span></span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> <span class="token number">7</span><span class="token punctuation">;</span> <span class="token punctuation">}</span>
</code></pre>
<p>上面代码中，<code>add7</code>函数其实是<code>add</code>函数的一个特殊版本，通过将一个参数绑定为<code>7</code>，就可以从<code>add</code>得到<code>add7</code>。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token comment" spellcheck="true">// bind 方法
</span>const add7 <span class="token operator">=</span> add<span class="token punctuation">.</span><span class="token function">bind<span class="token punctuation">(</span></span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">
// 箭头函数
</span>const add7 <span class="token operator">=</span> x <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token function">add<span class="token punctuation">(</span></span>x<span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>上面两种写法都有些冗余。其中，<code>bind</code>方法的局限更加明显，它必须提供<code>this</code>，并且只能从前到后一个个绑定参数，无法只绑定非头部的参数。</p>
<p>现在有一个<a href="https://github.com/tc39/proposal-partial-application">提案</a>，使得绑定参数并返回一个新函数更加容易。这叫做函数的部分执行（partial application）。</p>
<pre class=" language-javascript"><code class=" language-javascript">const add <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>
const addOne <span class="token operator">=</span> <span class="token function">add<span class="token punctuation">(</span></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

const maxGreaterThanZero <span class="token operator">=</span> Math<span class="token punctuation">.</span><span class="token function">max<span class="token punctuation">(</span></span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>根据新提案，<code>?</code>是单个参数的占位符，<code>...</code>是多个参数的占位符。以下的形式都属于函数的部分执行。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token function">f<span class="token punctuation">(</span></span>x<span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">)</span>
<span class="token function">f<span class="token punctuation">(</span></span>x<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
<span class="token function">f<span class="token punctuation">(</span></span><span class="token operator">?</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>
<span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> x<span class="token punctuation">)</span>
<span class="token function">f<span class="token punctuation">(</span></span><span class="token operator">?</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token operator">?</span><span class="token punctuation">)</span>
<span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> x<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
</code></pre>
<p><code>?</code>和<code>...</code>只能出现在函数的调用之中，并且会返回一个新函数。</p>
<pre class=" language-javascript"><code class=" language-javascript">const g <span class="token operator">=</span> <span class="token function">f<span class="token punctuation">(</span></span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">
// 等同于
</span>const g <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token function">f<span class="token punctuation">(</span></span>x<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>函数的部分执行，也可以用于对象的方法。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
  <span class="token function">f<span class="token punctuation">(</span></span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">,</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>

const g <span class="token operator">=</span> obj<span class="token punctuation">.</span><span class="token function">f<span class="token punctuation">(</span></span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">g<span class="token punctuation">(</span></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // 4
</span></code></pre>
<h3 id="注意点" class="注意点">注意点</h3>
<p>函数的部分执行有一些特别注意的地方。</p>
<p>（1）函数的部分执行是基于原函数的。如果原函数发生变化，部分执行生成的新函数也会立即反映这种变化。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">let</span> f <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>

const g <span class="token operator">=</span> <span class="token function">f<span class="token punctuation">(</span></span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">g<span class="token punctuation">(</span></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // 4
</span><span class="token comment" spellcheck="true">
// 替换函数 f
</span>f <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> x <span class="token operator">*</span> y<span class="token punctuation">;</span>

<span class="token function">g<span class="token punctuation">(</span></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // 3
</span></code></pre>
<p>上面代码中，定义了函数的部分执行以后，更换原函数会立即影响到新函数。</p>
<p>（2）如果预先提供的那个值是一个表达式，那么这个表达式并不会在定义时求值，而是在每次调用时求值。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
const f <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span>

const g <span class="token operator">=</span> <span class="token function">f<span class="token punctuation">(</span></span><span class="token operator">?</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">g<span class="token punctuation">(</span></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // 4
</span><span class="token comment" spellcheck="true">
// 改变 a 的值
</span>a <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
<span class="token function">g<span class="token punctuation">(</span></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // 11
</span></code></pre>
<p>上面代码中，预先提供的参数是变量<code>a</code>，那么每次调用函数<code>g</code>的时候，才会对<code>a</code>进行求值。</p>
<p>（3）如果新函数的参数多于占位符的数量，那么多余的参数将被忽略。</p>
<pre class=" language-javascript"><code class=" language-javascript">const f <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>
const g <span class="token operator">=</span> <span class="token function">f<span class="token punctuation">(</span></span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">g<span class="token punctuation">(</span></span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // [2, 1]
</span></code></pre>
<p>上面代码中，函数<code>g</code>只有一个占位符，也就意味着它只能接受一个参数，多余的参数都会被忽略。</p>
<p>写成下面这样，多余的参数就没有问题。</p>
<pre class=" language-javascript"><code class=" language-javascript">const f <span class="token operator">=</span> <span class="token punctuation">(</span>x<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>y<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>
const g <span class="token operator">=</span> <span class="token function">f<span class="token punctuation">(</span></span><span class="token operator">?</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">g<span class="token punctuation">(</span></span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // [2, 1, 3, 4];
</span></code></pre>
<p>（4）<code>...</code>只会被采集一次，如果函数的部分执行使用了多个<code>...</code>，那么每个<code>...</code>的值都将相同。</p>
<pre class=" language-javascript"><code class=" language-javascript">const f <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>x<span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> x<span class="token punctuation">;</span>
const g <span class="token operator">=</span> <span class="token function">f<span class="token punctuation">(</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">g<span class="token punctuation">(</span></span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // [1, 2, 3, 9, 1, 2, 3]
</span></code></pre>
<p>上面代码中，<code>g</code>定义了两个<code>...</code>占位符，真正执行的时候，它们的值是一样的。</p>
<h2 id="管道运算符" class="管道运算符">管道运算符</h2>
<p>Unix 操作系统有一个管道机制（pipeline），可以把前一个操作的值传给后一个操作。这个机制非常有用，使得简单的操作可以组合成为复杂的操作。许多语言都有管道的实现，现在有一个<a href="https://github.com/tc39/proposal-pipeline-operator">提案</a>，让 JavaScript 也拥有管道机制。</p>
<p>JavaScript 的管道是一个运算符，写作<code>|&gt;</code>。它的左边是一个表达式，右边是一个函数。管道运算符把左边表达式的值，传入右边的函数进行求值。</p>
<pre class=" language-javascript"><code class=" language-javascript">x <span class="token operator">|</span><span class="token operator">&gt;</span> f<span class="token comment" spellcheck="true">
// 等同于
</span><span class="token function">f<span class="token punctuation">(</span></span>x<span class="token punctuation">)</span>
</code></pre>
<p>管道运算符最大的好处，就是可以把嵌套的函数，写成从左到右的链式表达式。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> doubleSay <span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> str <span class="token operator">+</span> <span class="token string">", "</span> <span class="token operator">+</span> str<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> capitalize <span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> str<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">toUpperCase<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token operator">+</span> str<span class="token punctuation">.</span><span class="token function">substring<span class="token punctuation">(</span></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> exclaim <span class="token punctuation">(</span>str<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> str <span class="token operator">+</span> <span class="token string">'!'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面是三个简单的函数。如果要嵌套执行，传统的写法和管道的写法分别如下。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token comment" spellcheck="true">// 传统的写法
</span><span class="token function">exclaim<span class="token punctuation">(</span></span><span class="token function">capitalize<span class="token punctuation">(</span></span><span class="token function">doubleSay<span class="token punctuation">(</span></span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">
// "Hello, hello!"
</span><span class="token comment" spellcheck="true">
// 管道的写法
</span><span class="token string">'hello'</span>
  <span class="token operator">|</span><span class="token operator">&gt;</span> doubleSay
  <span class="token operator">|</span><span class="token operator">&gt;</span> capitalize
  <span class="token operator">|</span><span class="token operator">&gt;</span> exclaim<span class="token comment" spellcheck="true">
// "Hello, hello!"
</span></code></pre>
<p>管道运算符只能传递一个值，这意味着它右边的函数必须是一个单参数函数。如果是多参数函数，就必须进行柯里化，改成单参数的版本。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">function</span> double <span class="token punctuation">(</span>x<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> x<span class="token punctuation">;</span> <span class="token punctuation">}</span>
<span class="token keyword">function</span> add <span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> x <span class="token operator">+</span> y<span class="token punctuation">;</span> <span class="token punctuation">}</span>

<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token punctuation">{</span> score<span class="token punctuation">:</span> <span class="token number">25</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span>score
  <span class="token operator">|</span><span class="token operator">&gt;</span> double
  <span class="token operator">|</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span>_ <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token function">add<span class="token punctuation">(</span></span><span class="token number">7</span><span class="token punctuation">,</span> _<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">
// 57
</span></code></pre>
<p>上面代码中，<code>add</code>函数需要两个参数。但是，管道运算符只能传入一个值，因此需要事先提供另一个参数，并将其改成单参数的箭头函数<code>_ =&gt; add(7, _)</code>。这个函数里面的下划线并没有特别的含义，可以用其他符号代替，使用下划线只是因为，它能够形象地表示这里是占位符。</p>
<p>管道运算符对于<code>await</code>函数也适用。</p>
<pre class=" language-javascript"><code class=" language-javascript">x <span class="token operator">|</span><span class="token operator">&gt;</span> await f<span class="token comment" spellcheck="true">
// 等同于
</span>await <span class="token function">f<span class="token punctuation">(</span></span>x<span class="token punctuation">)</span>

const userAge <span class="token operator">=</span> userId <span class="token operator">|</span><span class="token operator">&gt;</span> await fetchUserById <span class="token operator">|</span><span class="token operator">&gt;</span> getAgeFromUser<span class="token punctuation">;</span><span class="token comment" spellcheck="true">
// 等同于
</span>const userAge <span class="token operator">=</span> <span class="token function">getAgeFromUser<span class="token punctuation">(</span></span>await <span class="token function">fetchUserById<span class="token punctuation">(</span></span>userId<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="数值分隔符" class="数值分隔符">数值分隔符</h2>
<p>欧美语言中，较长的数值允许每三位添加一个分隔符（通常是一个逗号），增加数值的可读性。比如，<code>1000</code>可以写作<code>1,000</code>。</p>
<p>现在有一个<a href="https://github.com/tc39/proposal-numeric-separator">提案</a>，允许 JavaScript 的数值使用下划线（<code>_</code>）作为分隔符。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">let</span> budget <span class="token operator">=</span> 1_000_000_000_000<span class="token punctuation">;</span>
budget <span class="token operator">===</span> <span class="token number">10</span> <span class="token operator">*</span><span class="token operator">*</span> <span class="token number">12</span><span class="token comment" spellcheck="true"> // true
</span></code></pre>
<p>JavaScript 的数值分隔符没有指定间隔的位数，也就是说，可以每三位添加一个分隔符，也可以每一位、每两位、每四位添加一个。</p>
<pre class=" language-javascript"><code class=" language-javascript">123_00 <span class="token operator">===</span> 12_300<span class="token comment" spellcheck="true"> // true
</span>
12345_00 <span class="token operator">===</span> 123_4500<span class="token comment" spellcheck="true"> // true
</span>12345_00 <span class="token operator">===</span> 1_234_500<span class="token comment" spellcheck="true"> // true
</span></code></pre>
<p>小数和科学计数法也可以使用数值分隔符。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token comment" spellcheck="true">// 小数
</span><span class="token number">0</span><span class="token punctuation">.</span>000_001<span class="token comment" spellcheck="true">
// 科学计数法
</span>1e10_000
</code></pre>
<p>数值分隔符有几个使用注意点。</p>
<ul>
<li>不能在数值的最前面（leading）或最后面（trailing）。</li>
<li>不能两个或两个以上的分隔符连在一起。</li>
<li>小数点的前后不能有分隔符。</li>
<li>科学计数法里面，表示指数的<code>e</code>或<code>E</code>前后不能有分隔符。</li>
</ul>
<p>下面的写法都会报错。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token comment" spellcheck="true">// 全部报错
</span>3_<span class="token number">.141</span>
<span class="token number">3</span><span class="token punctuation">.</span>_141
1_e12
1e_12
123__456
_1464301
1464301_
</code></pre>
<p>除了十进制，其他进制的数值也可以使用分隔符。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token comment" spellcheck="true">// 二进制
</span>0b1010_0001_1000_0101<span class="token comment" spellcheck="true">
// 十六进制
</span>0xA0_B0_C0
</code></pre>
<p>注意，分隔符不能紧跟着进制的前缀<code>0b</code>、<code>0B</code>、<code>0o</code>、<code>0O</code>、<code>0x</code>、<code>0X</code>。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token comment" spellcheck="true">// 报错
</span>0_b111111000
0b_111111000
</code></pre>
<p>下面三个将字符串转成数值的函数，不支持数值分隔符。主要原因是提案的设计者认为，数值分隔符主要是为了编码时书写数值的方便，而不是为了处理外部输入的数据。</p>
<ul>
<li>Number()</li>
<li>parseInt()</li>
<li>parseFloat()</li>
</ul>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token function">Number<span class="token punctuation">(</span></span><span class="token string">'123_456'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // NaN
</span><span class="token function">parseInt<span class="token punctuation">(</span></span><span class="token string">'123_456'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // 123
</span></code></pre>
<h2 id="BigInt-数据类型" class="BigInt-数据类型">BigInt 数据类型</h2>
<h3 id="简介" class="简介">简介</h3>
<p>JavaScript 所有数字都保存成 64 位浮点数，这给数值的表示带来了两大限制。一是数值的精度只能到 53 个二进制位（相当于 16 个十进制位），大于这个范围的整数，JavaScript 是无法精确表示的，这使得 JavaScript 不适合进行科学和金融方面的精确计算。二是大于或等于2的1024次方的数值，JavaScript 无法表示，会返回<code>Infinity</code>。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token comment" spellcheck="true">// 超过 53 个二进制位的数值，无法保持精度
</span>Math<span class="token punctuation">.</span><span class="token function">pow<span class="token punctuation">(</span></span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">53</span><span class="token punctuation">)</span> <span class="token operator">===</span> Math<span class="token punctuation">.</span><span class="token function">pow<span class="token punctuation">(</span></span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">53</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token comment" spellcheck="true"> // true
</span><span class="token comment" spellcheck="true">
// 超过 2 的 1024 次方的数值，无法表示
</span>Math<span class="token punctuation">.</span><span class="token function">pow<span class="token punctuation">(</span></span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">1024</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // Infinity
</span></code></pre>
<p>现在有一个<a href="https://github.com/tc39/proposal-bigint">提案</a>，引入了一种新的数据类型 BigInt（大整数），来解决这个问题。BigInt 只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。</p>
<pre class=" language-javascript"><code class=" language-javascript">const a <span class="token operator">=</span> 2172141653n<span class="token punctuation">;</span>
const b <span class="token operator">=</span> 15346349309n<span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">
// BigInt 可以保持精度
</span>a <span class="token operator">*</span> b<span class="token comment" spellcheck="true"> // 33334444555566667777n
</span><span class="token comment" spellcheck="true">
// 普通整数无法保持精度
</span><span class="token function">Number<span class="token punctuation">(</span></span>a<span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token function">Number<span class="token punctuation">(</span></span>b<span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // 33334444555566670000
</span></code></pre>
<p>为了与 Number 类型区别，BigInt 类型的数据必须添加后缀<code>n</code>。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token number">1234</span><span class="token comment" spellcheck="true"> // 普通整数
</span>1234n<span class="token comment" spellcheck="true"> // BigInt
</span><span class="token comment" spellcheck="true">
// BigInt 的运算
</span>1n <span class="token operator">+</span> 2n<span class="token comment" spellcheck="true"> // 3n
</span></code></pre>
<p>BigInt 同样可以使用各种进制表示，都要加上后缀<code>n</code>。</p>
<pre class=" language-javascript"><code class=" language-javascript">0b1101n<span class="token comment" spellcheck="true"> // 二进制
</span>0o777n<span class="token comment" spellcheck="true"> // 八进制
</span>0xFFn<span class="token comment" spellcheck="true"> // 十六进制
</span></code></pre>
<p>BigInt 与普通整数是两种值，它们之间并不相等。</p>
<pre class=" language-javascript"><code class=" language-javascript">42n <span class="token operator">===</span> <span class="token number">42</span><span class="token comment" spellcheck="true"> // false
</span></code></pre>
<p><code>typeof</code>运算符对于 BigInt 类型的数据返回<code>bigint</code>。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">typeof</span> 123n<span class="token comment" spellcheck="true"> // 'bigint'
</span></code></pre>
<p>BigInt 可以使用负号（<code>-</code>），但是不能使用正号（<code>+</code>），因为会与 asm.js 冲突。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token operator">-</span>42n<span class="token comment" spellcheck="true"> // 正确
</span><span class="token operator">+</span>42n<span class="token comment" spellcheck="true"> // 报错
</span></code></pre>
<h3 id="BigInt-对象" class="BigInt-对象">BigInt 对象</h3>
<p>JavaScript 原生提供<code>BigInt</code>对象，可以用作构造函数生成 BigInt 类型的数值。转换规则基本与<code>Number()</code>一致，将其他类型的值转为 BigInt。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token function">BigInt<span class="token punctuation">(</span></span><span class="token number">123</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // 123n
</span><span class="token function">BigInt<span class="token punctuation">(</span></span><span class="token string">'123'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // 123n
</span><span class="token function">BigInt<span class="token punctuation">(</span></span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // 0n
</span><span class="token function">BigInt<span class="token punctuation">(</span></span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // 1n
</span></code></pre>
<p><code>BigInt()</code>构造函数必须有参数，而且参数必须可以正常转为数值，下面的用法都会报错。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">new</span> <span class="token class-name">BigInt</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // TypeError
</span><span class="token function">BigInt<span class="token punctuation">(</span></span>undefined<span class="token punctuation">)</span><span class="token comment" spellcheck="true"> //TypeError
</span><span class="token function">BigInt<span class="token punctuation">(</span></span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // TypeError
</span><span class="token function">BigInt<span class="token punctuation">(</span></span><span class="token string">'123n'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // SyntaxError
</span><span class="token function">BigInt<span class="token punctuation">(</span></span><span class="token string">'abc'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // SyntaxError
</span></code></pre>
<p>上面代码中，尤其值得注意字符串<code>123n</code>无法解析成 Number 类型，所以会报错。</p>
<p>参数如果是小数，也会报错。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token function">BigInt<span class="token punctuation">(</span></span><span class="token number">1.5</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // RangeError
</span><span class="token function">BigInt<span class="token punctuation">(</span></span><span class="token string">'1.5'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // SyntaxError
</span></code></pre>
<p>BigInt 对象继承了 Object 提供的实例方法。</p>
<ul>
<li><code>BigInt.prototype.toLocaleString()</code></li>
<li><code>BigInt.prototype.toString()</code></li>
<li><code>BigInt.prototype.valueOf()</code></li>
</ul>
<p>此外，还提供了三个静态方法。</p>
<ul>
<li><code>BigInt.asUintN(width, BigInt)</code>： 给定的 BigInt 转为 0 到 2<sup>width</sup> - 1 之间对应的值。</li>
<li><code>BigInt.asIntN(width, BigInt)</code>：给定的 BigInt 转为 -2<sup>width - 1</sup> 到 2<sup>width - 1</sup> - 1 之间对应的值。</li>
<li><code>BigInt.parseInt(string[, radix])</code>：近似于<code>Number.parseInt()</code>，将一个字符串转换成指定进制的 BigInt。</li>
</ul>
<pre class=" language-javascript"><code class=" language-javascript">const max <span class="token operator">=</span> 2n <span class="token operator">*</span><span class="token operator">*</span> <span class="token punctuation">(</span>64n <span class="token operator">-</span> 1n<span class="token punctuation">)</span> <span class="token operator">-</span> 1n<span class="token punctuation">;</span>

BigInt<span class="token punctuation">.</span><span class="token function">asIntN<span class="token punctuation">(</span></span><span class="token number">64</span><span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token comment" spellcheck="true">
// 9223372036854775807n
</span>BigInt<span class="token punctuation">.</span><span class="token function">asIntN<span class="token punctuation">(</span></span><span class="token number">64</span><span class="token punctuation">,</span> max <span class="token operator">+</span> 1n<span class="token punctuation">)</span><span class="token comment" spellcheck="true">
// -9223372036854775808n
</span>BigInt<span class="token punctuation">.</span><span class="token function">asUintN<span class="token punctuation">(</span></span><span class="token number">64</span><span class="token punctuation">,</span> max <span class="token operator">+</span> 1n<span class="token punctuation">)</span><span class="token comment" spellcheck="true">
// 9223372036854775808n
</span></code></pre>
<p>上面代码中，<code>max</code>是64位带符号的 BigInt 所能表示的最大值。如果对这个值加<code>1n</code>，<code>BigInt.asIntN()</code>将会返回一个负值，因为这时新增的一位将被解释为符号位。而<code>BigInt.asUintN()</code>方法由于不存在符号位，所以可以正确返回结果。</p>
<p>如果<code>BigInt.asIntN()</code>和<code>BigInt.asUintN()</code>指定的位数，小于数值本身的位数，那么头部的位将被舍弃。</p>
<pre class=" language-javascript"><code class=" language-javascript">const max <span class="token operator">=</span> 2n <span class="token operator">*</span><span class="token operator">*</span> <span class="token punctuation">(</span>64n <span class="token operator">-</span> 1n<span class="token punctuation">)</span> <span class="token operator">-</span> 1n<span class="token punctuation">;</span>

BigInt<span class="token punctuation">.</span><span class="token function">asIntN<span class="token punctuation">(</span></span><span class="token number">32</span><span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // -1n
</span>BigInt<span class="token punctuation">.</span><span class="token function">asUintN<span class="token punctuation">(</span></span><span class="token number">32</span><span class="token punctuation">,</span> max<span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // 4294967295n
</span></code></pre>
<p>上面代码中，<code>max</code>是一个64位的 BigInt，如果转为32位，前面的32位都会被舍弃。</p>
<p>下面是<code>BigInt.parseInt()</code>的例子。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token comment" spellcheck="true">// Number.parseInt() 与 BigInt.parseInt() 的对比
</span>Number<span class="token punctuation">.</span><span class="token function">parseInt<span class="token punctuation">(</span></span><span class="token string">'9007199254740993'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">
// 9007199254740992
</span>BigInt<span class="token punctuation">.</span><span class="token function">parseInt<span class="token punctuation">(</span></span><span class="token string">'9007199254740993'</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">
// 9007199254740993n
</span></code></pre>
<p>上面代码中，由于有效数字超出了最大限度，<code>Number.parseInt</code>方法返回的结果是不精确的，而<code>BigInt.parseInt</code>方法正确返回了对应的 BigInt。</p>
<p>对于二进制数组，BigInt 新增了两个类型<code>BigUint64Array</code>和<code>BigInt64Array</code>，这两种数据类型返回的都是64位 BigInt。<code>DataView</code>对象的实例方法<code>DataView.prototype.getBigInt64()</code>和<code>DataView.prototype.getBigUint64()</code>，返回的也是 BigInt。</p>
<h3 id="转换规则" class="转换规则">转换规则</h3>
<p>可以使用<code>Boolean()</code>、<code>Number()</code>和<code>String()</code>这三个方法，将 BigInt 可以转为布尔值、数值和字符串类型。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token function">Boolean<span class="token punctuation">(</span></span>0n<span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // false
</span><span class="token function">Boolean<span class="token punctuation">(</span></span>1n<span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // true
</span><span class="token function">Number<span class="token punctuation">(</span></span>1n<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"> // 1
</span><span class="token function">String<span class="token punctuation">(</span></span>1n<span class="token punctuation">)</span> <span class="token comment" spellcheck="true"> // "1"
</span></code></pre>
<p>上面代码中，注意最后一个例子，转为字符串时后缀<code>n</code>会消失。</p>
<p>另外，取反运算符（<code>!</code>）也可以将 BigInt 转为布尔值。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token operator">!</span>0n<span class="token comment" spellcheck="true"> // true
</span><span class="token operator">!</span>1n<span class="token comment" spellcheck="true"> // false
</span></code></pre>
<h3 id="数学运算" class="数学运算">数学运算</h3>
<p>数学运算方面，BigInt 类型的<code>+</code>、<code>-</code>、<code>*</code>和<code>**</code>这四个二元运算符，与 Number 类型的行为一致。除法运算<code>/</code>会舍去小数部分，返回一个整数。</p>
<pre class=" language-javascript"><code class=" language-javascript">9n <span class="token operator">/</span> 5n<span class="token comment" spellcheck="true">
// 1n
</span></code></pre>
<p>几乎所有的数值运算符都可以用在 BigInt，但是有两个例外。</p>
<ul>
<li>不带符号的右移位运算符<code>&gt;&gt;&gt;</code></li>
<li>一元的求正运算符<code>+</code></li>
</ul>
<p>上面两个运算符用在 BigInt 会报错。前者是因为<code>&gt;&gt;&gt;</code>运算符是不带符号的，但是 BigInt 总是带有符号的，导致该运算无意义，完全等同于右移运算符<code>&gt;&gt;</code>。后者是因为一元运算符<code>+</code>在 asm.js 里面总是返回 Number 类型，为了不破坏 asm.js 就规定<code>+1n</code>会报错。</p>
<p>BigInt 不能与普通数值进行混合运算。</p>
<pre class=" language-javascript"><code class=" language-javascript">1n <span class="token operator">+</span> <span class="token number">1.3</span><span class="token comment" spellcheck="true"> // 报错
</span></code></pre>
<p>上面代码报错是因为无论返回的是 BigInt 或 Number，都会导致丢失精度信息。比如<code>(2n**53n + 1n) + 0.5</code>这个表达式，如果返回 BigInt 类型，<code>0.5</code>这个小数部分会丢失；如果返回 Number 类型，有效精度只能保持 53 位，导致精度下降。</p>
<p>同样的原因，如果一个标准库函数的参数预期是 Number 类型，但是得到的是一个 BigInt，就会报错。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token comment" spellcheck="true">// 错误的写法
</span>Math<span class="token punctuation">.</span><span class="token function">sqrt<span class="token punctuation">(</span></span>4n<span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // 报错
</span><span class="token comment" spellcheck="true">
// 正确的写法
</span>Math<span class="token punctuation">.</span><span class="token function">sqrt<span class="token punctuation">(</span></span><span class="token function">Number<span class="token punctuation">(</span></span>4n<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // 2
</span></code></pre>
<p>上面代码中，<code>Math.sqrt</code>的参数预期是 Number 类型，如果是 BigInt 就会报错，必须先用<code>Number</code>方法转一下类型，才能进行计算。</p>
<p>asm.js 里面，<code>|0</code>跟在一个数值的后面会返回一个32位整数。根据不能与 Number 类型混合运算的规则，BigInt 如果与<code>|0</code>进行运算会报错。</p>
<pre class=" language-javascript"><code class=" language-javascript">1n <span class="token operator">|</span> <span class="token number">0</span><span class="token comment" spellcheck="true"> // 报错
</span></code></pre>
<h3 id="其他运算" class="其他运算">其他运算</h3>
<p>BigInt 对应的布尔值，与 Number 类型一致，即<code>0n</code>会转为<code>false</code>，其他值转为<code>true</code>。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">if</span> <span class="token punctuation">(</span>0n<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span><span class="token string">'if'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span><span class="token string">'else'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token comment" spellcheck="true">
// else
</span></code></pre>
<p>上面代码中，<code>0n</code>对应<code>false</code>，所以会进入<code>else</code>子句。</p>
<p>比较运算符（比如<code>&gt;</code>）和相等运算符（<code>==</code>）允许 BigInt 与其他类型的值混合计算，因为这样做不会损失精度。</p>
<pre class=" language-javascript"><code class=" language-javascript">0n <span class="token operator">&lt;</span> <span class="token number">1</span><span class="token comment" spellcheck="true"> // true
</span>0n <span class="token operator">&lt;</span> <span class="token boolean">true</span><span class="token comment" spellcheck="true"> // true
</span>0n <span class="token operator">==</span> <span class="token number">0</span><span class="token comment" spellcheck="true"> // true
</span>0n <span class="token operator">==</span> <span class="token boolean">false</span><span class="token comment" spellcheck="true"> // true
</span>0n <span class="token operator">===</span> <span class="token number">0</span><span class="token comment" spellcheck="true"> // false
</span></code></pre>
<p>BigInt 与字符串混合运算时，会先转为字符串，再进行运算。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token string">''</span> <span class="token operator">+</span> 123n<span class="token comment" spellcheck="true"> // "123"
</span></code></pre>
<h2 id="Math-signbit" class="Math-signbit">Math.signbit()</h2>
<p><code>Math.sign()</code>用来判断一个值的正负，但是如果参数是<code>-0</code>，它会返回<code>-0</code>。</p>
<pre class=" language-javascript"><code class=" language-javascript">Math<span class="token punctuation">.</span><span class="token function">sign<span class="token punctuation">(</span></span><span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // -0
</span></code></pre>
<p>这导致对于判断符号位的正负，<code>Math.sign()</code>不是很有用。JavaScript 内部使用 64 位浮点数（国际标准 IEEE 754）表示数值，IEEE 754 规定第一位是符号位，<code>0</code>表示正数，<code>1</code>表示负数。所以会有两种零，<code>+0</code>是符号位为<code>0</code>时的零值，<code>-0</code>是符号位为<code>1</code>时的零值。实际编程中，判断一个值是<code>+0</code>还是<code>-0</code>非常麻烦，因为它们是相等的。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token operator">+</span><span class="token number">0</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">0</span><span class="token comment" spellcheck="true"> // true
</span></code></pre>
<p>目前，有一个<a href="http://jfbastien.github.io/papers/Math.signbit.html">提案</a>，引入了<code>Math.signbit()</code>方法判断一个数的符号位是否设置了。</p>
<pre class=" language-javascript"><code class=" language-javascript">Math<span class="token punctuation">.</span><span class="token function">signbit<span class="token punctuation">(</span></span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> //false
</span>Math<span class="token punctuation">.</span><span class="token function">signbit<span class="token punctuation">(</span></span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> //true
</span>Math<span class="token punctuation">.</span><span class="token function">signbit<span class="token punctuation">(</span></span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> //false
</span>Math<span class="token punctuation">.</span><span class="token function">signbit<span class="token punctuation">(</span></span><span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> //true
</span></code></pre>
<p>可以看到，该方法正确返回了<code>-0</code>的符号位是设置了的。</p>
<p>该方法的算法如下。</p>
<ul>
<li>如果参数是<code>NaN</code>，返回<code>false</code></li>
<li>如果参数是<code>-0</code>，返回<code>true</code></li>
<li>如果参数是负值，返回<code>true</code></li>
<li>其他情况返回<code>false</code></li>
</ul>
<h2 id="双冒号运算符" class="双冒号运算符">双冒号运算符</h2>
<p>箭头函数可以绑定<code>this</code>对象，大大减少了显式绑定<code>this</code>对象的写法（<code>call</code>、<code>apply</code>、<code>bind</code>）。但是，箭头函数并不适用于所有场合，所以现在有一个<a href="https://github.com/zenparsing/es-function-bind">提案</a>，提出了“函数绑定”（function bind）运算符，用来取代<code>call</code>、<code>apply</code>、<code>bind</code>调用。</p>
<p>函数绑定运算符是并排的两个冒号（<code>::</code>），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即<code>this</code>对象），绑定到右边的函数上面。</p>
<pre class=" language-javascript"><code class=" language-javascript">foo<span class="token punctuation">:</span><span class="token punctuation">:</span>bar<span class="token punctuation">;</span><span class="token comment" spellcheck="true">
// 等同于
</span>bar<span class="token punctuation">.</span><span class="token function">bind<span class="token punctuation">(</span></span>foo<span class="token punctuation">)</span><span class="token punctuation">;</span>

foo<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">bar<span class="token punctuation">(</span></span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true">
// 等同于
</span>bar<span class="token punctuation">.</span><span class="token function">apply<span class="token punctuation">(</span></span>foo<span class="token punctuation">,</span> arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>

const hasOwnProperty <span class="token operator">=</span> Object<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>hasOwnProperty<span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">hasOwn<span class="token punctuation">(</span></span>obj<span class="token punctuation">,</span> key<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> obj<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">hasOwnProperty<span class="token punctuation">(</span></span>key<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre>
<p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">var</span> method <span class="token operator">=</span> obj<span class="token punctuation">:</span><span class="token punctuation">:</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">;</span><span class="token comment" spellcheck="true">
// 等同于
</span><span class="token keyword">var</span> method <span class="token operator">=</span> <span class="token punctuation">:</span><span class="token punctuation">:</span>obj<span class="token punctuation">.</span>foo<span class="token punctuation">;</span>

<span class="token keyword">let</span> log <span class="token operator">=</span> <span class="token punctuation">:</span><span class="token punctuation">:</span>console<span class="token punctuation">.</span>log<span class="token punctuation">;</span><span class="token comment" spellcheck="true">
// 等同于
</span><span class="token keyword">var</span> log <span class="token operator">=</span> console<span class="token punctuation">.</span>log<span class="token punctuation">.</span><span class="token function">bind<span class="token punctuation">(</span></span>console<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法。</p>
<pre class=" language-javascript"><code class=" language-javascript">import <span class="token punctuation">{</span> map<span class="token punctuation">,</span> takeWhile<span class="token punctuation">,</span> forEach <span class="token punctuation">}</span> from <span class="token string">"iterlib"</span><span class="token punctuation">;</span>

<span class="token function">getPlayers<span class="token punctuation">(</span></span><span class="token punctuation">)</span>
<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">map<span class="token punctuation">(</span></span>x <span class="token operator">=</span><span class="token operator">&gt;</span> x<span class="token punctuation">.</span><span class="token function">character<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">takeWhile<span class="token punctuation">(</span></span>x <span class="token operator">=</span><span class="token operator">&gt;</span> x<span class="token punctuation">.</span>strength <span class="token operator">&gt;</span> <span class="token number">100</span><span class="token punctuation">)</span>
<span class="token punctuation">:</span><span class="token punctuation">:</span><span class="token function">forEach<span class="token punctuation">(</span></span>x <span class="token operator">=</span><span class="token operator">&gt;</span> console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span>x<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<h2 id="Realm-API" class="Realm-API">Realm API</h2>
<p><a href="https://github.com/tc39/proposal-realms">Realm API</a> 提供沙箱功能（sandbox），允许隔离代码，防止那些被隔离的代码拿到全局对象。</p>
<p>以前，经常使用<code>&lt;iframe&gt;</code>作为沙箱。</p>
<pre class=" language-javascript"><code class=" language-javascript">const globalOne <span class="token operator">=</span> window<span class="token punctuation">;</span>
<span class="token keyword">let</span> iframe <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">createElement<span class="token punctuation">(</span></span><span class="token string">'iframe'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild<span class="token punctuation">(</span></span>iframe<span class="token punctuation">)</span><span class="token punctuation">;</span>
const globalTwo <span class="token operator">=</span> iframe<span class="token punctuation">.</span>contentWindow<span class="token punctuation">;</span>
</code></pre>
<p>上面代码中，<code>&lt;iframe&gt;</code>的全局对象是独立的（<code>iframe.contentWindow</code>）。Realm API 可以取代这个功能。</p>
<pre class=" language-javascript"><code class=" language-javascript">const globalOne <span class="token operator">=</span> window<span class="token punctuation">;</span>
const globalTwo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Realm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>global<span class="token punctuation">;</span>
</code></pre>
<p>上面代码中，<code>Realm API</code>单独提供了一个全局对象<code>new Realm().global</code>。</p>
<p>Realm API 提供一个<code>Realm()</code>构造函数，用来生成一个 Realm 对象。该对象的<code>global</code>属性指向一个新的顶层对象，这个顶层对象跟原始的顶层对象类似。</p>
<pre class=" language-javascript"><code class=" language-javascript">const globalOne <span class="token operator">=</span> window<span class="token punctuation">;</span>
const globalTwo <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Realm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>global<span class="token punctuation">;</span>

globalOne<span class="token punctuation">.</span><span class="token function">evaluate<span class="token punctuation">(</span></span><span class="token string">'1 + 2'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // 3
</span>globalTwo<span class="token punctuation">.</span><span class="token function">evaluate<span class="token punctuation">(</span></span><span class="token string">'1 + 2'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true"> // 3
</span></code></pre>
<p>上面代码中，Realm 生成的顶层对象的<code>evaluate()</code>方法，可以运行代码。</p>
<p>下面的代码可以证明，Realm 顶层对象与原始顶层对象是两个对象。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token keyword">let</span> a1 <span class="token operator">=</span> globalOne<span class="token punctuation">.</span><span class="token function">evaluate<span class="token punctuation">(</span></span><span class="token string">'[1,2,3]'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> a2 <span class="token operator">=</span> globalTwo<span class="token punctuation">.</span><span class="token function">evaluate<span class="token punctuation">(</span></span><span class="token string">'[1,2,3]'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a1<span class="token punctuation">.</span>prototype <span class="token operator">===</span> a2<span class="token punctuation">.</span>prototype<span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // false
</span>a1 <span class="token keyword">instanceof</span> <span class="token class-name">globalTwo<span class="token punctuation">.</span>Array</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // false
</span>a2 <span class="token keyword">instanceof</span> <span class="token class-name">globalOne<span class="token punctuation">.</span>Array</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // false
</span></code></pre>
<p>上面代码中，Realm 沙箱里面的数组的原型对象，跟原始环境里面的数组是不一样的。</p>
<p>Realm 沙箱里面只能运行 ECMAScript 语法提供的 API，不能运行宿主环境提供的 API。</p>
<pre class=" language-javascript"><code class=" language-javascript">globalTwo<span class="token punctuation">.</span><span class="token function">evaluate<span class="token punctuation">(</span></span><span class="token string">'console.log(1)'</span><span class="token punctuation">)</span><span class="token comment" spellcheck="true">
// throw an error: console is undefined
</span></code></pre>
<p>上面代码中，Realm 沙箱里面没有<code>console</code>对象，导致报错。因为<code>console</code>不是语法标准，是宿主环境提供的。</p>
<p>如果要解决这个问题，可以使用下面的代码。</p>
<pre class=" language-javascript"><code class=" language-javascript">globalTwo<span class="token punctuation">.</span>console <span class="token operator">=</span> globalOne<span class="token punctuation">.</span>console<span class="token punctuation">;</span>
</code></pre>
<p><code>Realm()</code>构造函数可以接受一个参数对象，该参数对象的<code>intrinsics</code>属性可以指定 Realm 沙箱继承原始顶层对象的方法。</p>
<pre class=" language-javascript"><code class=" language-javascript">const r1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Realm</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
r1<span class="token punctuation">.</span>global <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">;</span>
r1<span class="token punctuation">.</span>global<span class="token punctuation">.</span>JSON <span class="token operator">===</span> JSON<span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // false
</span>
const r2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Realm</span><span class="token punctuation">(</span><span class="token punctuation">{</span> intrinsics<span class="token punctuation">:</span> <span class="token string">'inherit'</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
r2<span class="token punctuation">.</span>global <span class="token operator">===</span> <span class="token keyword">this</span><span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // false
</span>r2<span class="token punctuation">.</span>global<span class="token punctuation">.</span>JSON <span class="token operator">===</span> JSON<span class="token punctuation">;</span><span class="token comment" spellcheck="true"> // true
</span></code></pre>
<p>上面代码中，正常情况下，沙箱的<code>JSON</code>方法不同于原始的<code>JSON</code>对象。但是，<code>Realm()</code>构造函数接受<code>{ intrinsics: 'inherit' }</code>作为参数以后，就会继承原始顶层对象的方法。</p>
<p>用户可以自己定义<code>Realm</code>的子类，用来定制自己的沙箱。</p>
<pre class=" language-javascript"><code class=" language-javascript">class <span class="token class-name">FakeWindow</span> extends <span class="token class-name">Realm</span> <span class="token punctuation">{</span>
  <span class="token function">init<span class="token punctuation">(</span></span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    super<span class="token punctuation">.</span><span class="token function">init<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> global <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>global<span class="token punctuation">;</span>

    global<span class="token punctuation">.</span>document <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">FakeDocument</span><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    global<span class="token punctuation">.</span>alert <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>fakeAlert<span class="token punctuation">,</span> <span class="token punctuation">{</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span> <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
   <span class="token comment" spellcheck="true"> // ...
</span>  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre>
<p>上面代码中，<code>FakeWindow</code>模拟了一个假的顶层对象<code>window</code>。</p>
<h2 id="-!命令" class="-!命令"><code>#!</code>命令</h2>
<p>Unix 的命令行脚本都支持<code>#!</code>命令，又称为 Shebang 或 Hashbang。这个命令放在脚本的第一行，用来指定脚本的执行器。</p>
<p>比如 Bash 脚本的第一行。</p>
<pre class=" language-bash"><code class=" language-bash"><span class="token important">#!/bin/sh</span>
</code></pre>
<p>Python 脚本的第一行。</p>
<pre><code class="lang-python">#!/usr/bin/env python
</code></pre>
<p>现在有一个<a href="https://github.com/tc39/proposal-hashbang">提案</a>，为 JavaScript 脚本引入了<code>#!</code>命令，写在脚本文件或者模块文件的第一行。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token comment" spellcheck="true">// 写在脚本文件第一行
</span>#<span class="token operator">!</span><span class="token operator">/</span>usr<span class="token operator">/</span>bin<span class="token operator">/</span>env node
<span class="token string">'use strict'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment" spellcheck="true">
// 写在模块文件第一行
</span>#<span class="token operator">!</span><span class="token operator">/</span>usr<span class="token operator">/</span>bin<span class="token operator">/</span>env node
export <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log<span class="token punctuation">(</span></span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>有了这一行以后，Unix 命令行就可以直接执行脚本。</p>
<pre class=" language-bash"><code class=" language-bash"><span class="token comment" spellcheck="true"># 以前执行脚本的方式
</span>$ node hello<span class="token punctuation">.</span>js

<span class="token comment" spellcheck="true"># hashbang 的方式
</span>$ hello<span class="token punctuation">.</span>js
</code></pre>
<p>对于 JavaScript 引擎来说，会把<code>#!</code>理解成注释，忽略掉这一行。</p>
<h2 id="import-meta" class="import-meta">import.meta</h2>
<p>加载 JavaScript 脚本的时候，有时候需要知道脚本的元信息。Node.js 提供了两个特殊变量<code>__filename</code>和<code>__dirname</code>，用来获取脚本的文件名和所在路径。</p>
<pre class=" language-javascript"><code class=" language-javascript">const fs <span class="token operator">=</span> <span class="token function">require<span class="token punctuation">(</span></span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
const path <span class="token operator">=</span> <span class="token function">require<span class="token punctuation">(</span></span><span class="token string">'path'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
const bytes <span class="token operator">=</span> fs<span class="token punctuation">.</span><span class="token function">readFileSync<span class="token punctuation">(</span></span>path<span class="token punctuation">.</span><span class="token function">resolve<span class="token punctuation">(</span></span>__dirname<span class="token punctuation">,</span> <span class="token string">'data.bin'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>上面代码中，<code>__dirname</code>用于加载与脚本同一个目录的数据文件<code>data.bin</code>。</p>
<p>但是，浏览器没有这两个特殊变量。如果需要知道脚本的元信息，就只有手动提供。</p>
<pre><code class="lang-html">&lt;script data-option="value" src="library.js"&gt;&lt;/script&gt;
</code></pre>
<p>上面这一行 HTML 代码加载 JavaScript 脚本，使用<code>data-</code>属性放入元信息。如果脚本内部要获知元信息，可以像下面这样写。</p>
<pre class=" language-javascript"><code class=" language-javascript">const theOption <span class="token operator">=</span> document<span class="token punctuation">.</span>currentScript<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>option<span class="token punctuation">;</span>
</code></pre>
<p>上面代码中，<code>document.currentScript</code>属性可以拿到当前脚本的 DOM 节点。</p>
<p>由于 Node.js 和浏览器做法的不统一，现在有一个<a href="https://github.com/tc39/proposal-import-meta">提案</a>，提出统一使用<code>import.meta</code>属性在脚本内部获取元信息。这个属性返回一个对象，该对象的各种属性就是当前运行的脚本的元信息。具体包含哪些属性，标准没有规定，由各个运行环境自行决定。</p>
<p>一般来说，浏览器的<code>import.meta</code>至少会有两个属性。</p>
<ul>
<li><code>import.meta.url</code>：脚本的 URL。</li>
<li><code>import.meta.scriptElement</code>：加载脚本的那个<code>&lt;script&gt;</code>的 DOM 节点，用来替代<code>document.currentScript</code>。</li>
</ul>
<pre><code class="lang-html">&lt;script type="module" src="path/to/hamster-displayer.js" data-size="500"&gt;&lt;/script&gt;
</code></pre>
<p>上面这行代码加载的脚本内部，就可以使用<code>import.meta</code>获取元信息。</p>
<pre class=" language-javascript"><code class=" language-javascript"><span class="token punctuation">(</span>async <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=</span><span class="token operator">&gt;</span> <span class="token punctuation">{</span>
  const response <span class="token operator">=</span> await <span class="token function">fetch<span class="token punctuation">(</span></span><span class="token keyword">new</span> <span class="token class-name">URL</span><span class="token punctuation">(</span><span class="token string">"../hamsters.jpg"</span><span class="token punctuation">,</span> import<span class="token punctuation">.</span>meta<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  const blob <span class="token operator">=</span> await response<span class="token punctuation">.</span><span class="token function">blob<span class="token punctuation">(</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>

  const size <span class="token operator">=</span> import<span class="token punctuation">.</span>meta<span class="token punctuation">.</span>scriptElement<span class="token punctuation">.</span>dataset<span class="token punctuation">.</span>size <span class="token operator">||</span> <span class="token number">300</span><span class="token punctuation">;</span>

  const image <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  image<span class="token punctuation">.</span>src <span class="token operator">=</span> URL<span class="token punctuation">.</span><span class="token function">createObjectURL<span class="token punctuation">(</span></span>blob<span class="token punctuation">)</span><span class="token punctuation">;</span>
  image<span class="token punctuation">.</span>width <span class="token operator">=</span> image<span class="token punctuation">.</span>height <span class="token operator">=</span> size<span class="token punctuation">;</span>

  document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">appendChild<span class="token punctuation">(</span></span>image<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre>
<p>上面代码中，<code>import.meta</code>用来获取所加载的图片的尺寸。</p>
<h3 class="留言" id="留言">留言</h3><div id="disqus_thread"></div></div>
  <!-- optional -->
  <div id="back_to_top" style="display: block;">back to top</div>
  <div id="edit" style="display: block;">edit</div>
  <div id="loading" style="display: none;">Loading ...</div>
  <div id="error" style="display: none;">Oops! ... File not found!</div>
  <div id="flip"><div id="pageup" style="display: inline-block;">上一章</div><div id="pagedown" style="display: inline-block;">下一章</div></div>
  <div class="progress-indicator-2" style="width: 0%;"></div>


  <noscript>
    <p>《ECMAScript 6入门》是一本开源的JavaScript语言教程，全面介绍ECMAScript 6新增的语法特性。</p>
    <p>本书力争覆盖ES6与ES5的所有不同之处，对涉及的语法知识给予详细介绍，并给出大量简洁易懂的示例代码。</p>
    <p>本书为中级难度，适合已有一定JavaScript语言基础的读者，了解这门语言的最新进展；也可当作参考手册，查寻新增的语法点。</p>
  </noscript>


</body></html>